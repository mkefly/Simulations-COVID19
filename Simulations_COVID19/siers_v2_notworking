import numpy as np
import pandas as pd
import pymc3 as pm
from pymc3.ode import DifferentialEquation
from scipy.integrate import odeint
import arviz as az
import theano
import matplotlib.pyplot as plt
from datetime import timedelta, datetime
from scipy.optimize import minimize
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

from .utilitis import data_loader # as data_loader

class siers_simulator(data_loader):
    def __init__(self, country, delta, gammaR, gammaD, mu, beta0, alpha, omega, epsilon, population, bounds, Dates = None, data_table = None):
        self.country = country
        self.Dates = Dates
        # Total population, N.
        self.N = population 
        # Initial number of infected and recovered individuals, I0 and R0.
        self.E0, self.IR0, self.ID0, self.R0, self.D0 = 0, 0, 0, 0, 0

        # Everyone else, S0, is susceptible to infection initially.
        self.S0 = self.N - self.E0 - self.IR0 - self.ID0 - self.R0 + self.D0
        
        # Contact rate, beta, and mean recovery rate, gamma, (in 1/days).
        
        self.delta = delta
        self.gammaR = gammaR
        self.gammaD = gammaD
        self.mu = mu
        self.epsilon = epsilon
        self.omega = omega 
        self.beta0 = beta0
        self.alpha = alpha
        self.tbeta_flag = 0
        
        self.bounds = bounds

        # A grid of time points (in days)
        self.t = np.linspace(0, 200, 200)
        
        if data_table is not None:
            self.get_data_from_object(data_table)
        else:
            self.data_read = {}
            for field in ['Confirmed','Recovered','Deaths']:
                self.recover_data(field)
            self.get_data_from_object(self.load_data(self.country))
            self.data_read = [] 
        if not (self.Dates is None):
            for key, value in self.Dates[self.country].items():
                self.dates_ind = np.argwhere(self.data['Date'] == key)[0][0] 
                self.beta_t0 = self.dates_ind
        
    def get_data_from_object(self, data_table):
        self.data = data_table[data_table["Country"].isin([self.country])]
        return self.data
    
    def deriv_theta(self, y, t, theta):

        delta = theta[0]
        gammaR = theta[1]
        gammaD = theta[2]
        omega = theta[3]
        beta0 = theta[4]
        alpha = theta[5]
        beta_t0 = theta[6]
        mu = theta[7]
        epsilon = theta[8]
        
        self.deriv(y, t, delta, gammaR, gammaD, mu, beta0, alpha, beta_t0, epsilon, omega)
        y10 = (self.dSdt, self.dEdt, self.dIRdt, self.dIDdt, self.dRdt, self.dDdt)

        return y10    
    
    def beta_f(self, t):
        """
        calculate beta based on some function
        """
        return self.beta0*(1-1/(1 + np.exp(-(self.alpha * (t - self.beta_t0)))))

    # The SIERs model differential equations.
    def deriv(self, y, t, delta, gammaR, gammaD, mu, beta0, alpha, beta_t0, epsilon, omega):
        
        self.S = y[0]
        self.E = y[1]
        self.IR = y[2]
        self.ID = y[3]
        self.R = y[4]
        self.D = y[5]

        beta = self.beta_f(t)      

        self.dSdt = - beta * self.S * (self.IR + self.ID) / self.N #+ omega * self.R
        self.dEdt = beta * self.S * (self.IR + self.ID) / self.N  - delta * self.E
        self.dIRdt = delta * (1 - self.mu) * self.E - gammaR * self.IR #+ epsilon
        self.dIDdt = delta * self.mu * self.E - gammaD * self.ID #+ epsilon
        self.dRdt = gammaR * self.IR #- omega * self.R  ### omega: rate waning immunity
        self.dDdt = gammaD * self.ID

        self.N -= self.D0 

        return self.dSdt, self.dEdt, self.dIRdt, self.dIDdt, self.dRdt, self.dDdt

    def integrate(self):

        # Initial conditions vector
        self.y0 = self.S0, self.E0, self.IR0, self.ID0, self.R0, self.D0
        theta = [self.delta, self.gammaR, self.gammaD, self.mu, self.beta0, self.alpha, self.beta_t0, self.epsilon, self.omega]
        # Integrate the SEIRs equations over the time grid, t.
        ret = odeint(self.deriv_theta, self.y0, self.t, args=(theta,), mxstep=15000)
    
        self.S, self.E, self.IR, self.ID, self.R, self.D = ret.T
        
        return ret.T

    def plot_results(self, xlim = [24,200], ylim = [0,20000] ,N = 0):
        plt.style.use('dark_background')
        self.fig, self.ax = plt.subplots(1, 1, figsize=[17, 7])
        plt.title(self.country)
        self.plot_update(xlim = xlim, ylim = ylim ,N = N)
    
    def plot_update(self, xlim = [24,200], ylim = [0,20000] ,N = 0, add_dat = True):
                        
        # Plot the data on three separate curves for S(t), I(t) and R(t)
        # Create inset of width 30% and height 40% of the parent axes' bounding box
        # at the lower left corner (loc=3)
        
        self.axins2 = inset_axes(self.ax, width="30%", height="40%", loc=4)
        
        self.ax.plot(np.pad(self.E, (N, 0), 'constant'), '--', alpha=0.5, lw=2, label='Sim. Exposed')
        self.ax.plot(np.pad(self.ID + self.IR, (N, 0), 'constant'), 'r--', alpha=0.5, lw=2, label='Sim. Infected')
        self.ax.plot(np.pad(self.R, (N, 0), 'constant') ,'g--', alpha=0.5, lw=2, label='Sim. Recovered with immunity')
        self.ax.plot(np.pad(self.D, (N, 0), 'constant'),'--', color = 'white', alpha=0.5, lw=2, label='Sim. Death')
        
        self.ax.set_xlabel('Time /days')
        self.ax.set_ylabel('# People')

        #.grid(b=True, which='major', c='w', lw=2, ls='-')
        
        if add_dat:
            self.plot_add_data()          
            
        self.ax.legend()
        self.ax.set_xlim(xlim)
        self.ax.set_ylim(ylim)

        #fig = plt.figure(figsize=(17,7))
        self.axins2.plot(np.pad(self.beta_f(self.t), (N, 0), 'constant', 
                        constant_values=(self.beta_f(1), 0)),'--', color = 'white' , alpha=0.5, lw=2, label='beta_function - Day:'+str(self.beta_t0)+'Slope:'+str(self.alpha))
        self.axins2.legend()
        
        # Turn ticklabels of insets off
        self.axins2.tick_params(labelleft=False, labelbottom=False)

    def plot_add_data(self):
        self.ax.scatter(self.data['Days'], self.data['Deaths'], label = 'real Deaths')
        self.ax.scatter(self.data['Days'], self.data['Recovered'], label = 'real Infected')
        self.ax.scatter(self.data['Days'], self.data['Confirmed']-self.data['Recovered']-self.data['Deaths'], label = 'real Infected')

        if not (self.Dates is None):
            for key, value in self.Dates[self.country].items():
                ind = np.argwhere(self.data['Date'] == key)[0][0]
                self.ax.plot([ind,ind],[0,3000000], value[1], label = self.country+'-'+ value[0])
    
    def train(self, flag_two_stages = True):
        run_stages = 0
        while run_stages == 0:
            run_stages = 0
            
            if flag_two_stages:
                self.beta_t0 = 100000000
                self.loss_data = self.data[:self.dates_ind]
                self.t = self.loss_data['Days']
                flag_two_stages = False
                run_stages = 1
                
            flag_two_stages = False    
                
            if run_stages == 0:    
                self.beta_t0 = self.dates_ind
                self.loss_data = self.data
                self.t = self.loss_data['Days']
            
            self.optimal = minimize(self.loss, 
                method = 'L-BFGS-B',
                bounds = self.bounds,
                x0 = [self.E0, self.delta, self.gammaR, self.gammaD, self.mu, self.beta0, self.alpha, self.beta_t0])#, self.alpha, self.beta_t0, self.epsilon, self.omega])

            print(self.optimal)
            print()
            bounds = [(self.E0*(1-1/10),self.E0*(1-1/10)),
                      (1/(1/self.delta - 2 ),1/(1/self.delta - 2 )),
                      (1/(1/self.gammaR - 2 ),1/(1/self.gammaR - 2 )),
                      (1/(1/self.gammaD - 2 ),1/(1/self.gammaD - 2 )),
                      (self.mu*(1-1/10),self.mu*(1-1/10)),
                      (self.beta0*(1-1/10),self.beta0*(1-1/10)),
                      (0.001,10),
                      (self.beta_t0, self.beta_t0 + 1)]
            
        
        print('δ: Days for symptoms to appear: '+ str(1/self.delta))
        print('1/γR: Days to recovery: '+ str(1/self.gammaR))
        print('1/γD: Days to death: '+ str(1/self.gammaD))
        print('μ: proportion of cases who die: '+ str(self.mu))
        print('E0: initial exposed: '+ str(self.E0))
        print('β0: rate of infection: '+ str(self.beta0))
        print('Days before Lockdown: '+ str(self.beta_t0))
        print('Lockdown strength: '+ str(self.alpha))
        print('R0: '+ str(self.R_0))
    
        self.E0, self.delta, self.gammaR, self.gammaD, self.mu, self.beta0, self.alpha, self.beta_t0  = self.optimal.x #, self.alpha, self.beta_t0 , self.epsilon, self.omega  = self.optimal.x
        self.t = np.linspace(0, 200, 200)
        self.prediction = self.integrate()
        

    def loss(self, point):
        self.E0, self.delta, self.gammaR, self.gammaD, self.mu, self.beta0, self.alpha, self.beta_t0  = point

        self.R_0 = self.beta0 / (self.gammaR + self.gammaD)
        self.integrate()
        
        Infected = self.data['Confirmed'].values - self.data['Recovered'].values - self.data['Deaths'].values
        
        lR_0 = np.abs(self.R_0 - 3.5) + np.abs(self.R_0 - 1.9)
        
        lA = np.mean((self.t*(self.IR + self.ID - Infected))**10)**(1/10)
        
        l11 = np.sqrt(np.mean(self.t*((self.IR + self.ID - Infected))**2))
        l21 = np.sqrt(np.mean(self.t*((self.R - self.data['Recovered'].values))**2))
        l31 = np.sqrt(np.mean(self.t*((self.D - self.data['Deaths'].values))**2))
        
        return np.sqrt((l31)**2 + ((l21))**2+ ((l11))**2)  # + lR0 + lA
    
                